<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Shell"><link rel=alternate type=application/rss+xml href=https://debdut.blog/categories/shell/index.xml title=Blog><title>Shell | Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.65786b6760ea3c403949936f979b526a1d34bf8b89348396fa265540bc532322.css media=all></head><body><nav><ul class=menu></ul></nav><h1>Shell</h1><ul class=post-list><li><div style="display:grid;grid-template-columns:7em auto"><span class=date>Jun 8, 2022</span>
<a href=/2022/06/creating-shell-builtins/>Creating Shell Builtins</a></div></li></ul><br><footer><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));window.addEventListener("scroll",function(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}})}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"https://debdut.blog/":{title:"Blog",tags:[],content:"",url:"https://debdut.blog/"},"https://debdut.blog/2024/03/fundamental-theory-of-arithmetic/":{title:"Fundamental Theory of Arithmetic",tags:["mathematics","number-theory"],content:` There is one and only one unique prime factorization of a number.
If you have a number, like \\(34\\), factoring it we get -
$$ \\begin{align} fact(34) = 2 * 17 \\end{align} $$
Question is, can you have a different set that is other than { \\(2\\) } It may seem evident from the example above but let’s start with an informal proof.
Firstly, we&rsquo;ll use a different definition of a set, where elements can show up multiple times - this is critical in making the proof simpler.
Suppose the set representing all the primes of a number is \\(S =\\) { \\(a_1, a_2, a_3, \\dots, a_i\\) } for \\(i \\in \\mathbb{N}\\) and \\(S \\subset \\mathbb{P}\\). Let’s also change the number to \\(988\\), something you can’t factor in your head (at least I hope not).
Recalling a prime, is a number that can not be factored any further, or better yet a number that is divisible by 1 and itself.
This establishes a uniqueness to a prime number, that it is it. You can’t replace one prime for another, because they represent a specific count, that can’t even be further broken down in terms of factors.
A number can be represented as a multiple of many primes. Let’s say \\(988\\) is a multiple of \\((a_1, a_2, a_3, \\dots, a_i)\\) (same as set \\(S\\)), ordered in ascending. Therefore, if \\(\\vert S \\vert = i\\) (number of elements in a set, recall, in our definition of a set, we can have duplicates), \\(i\\) is a constant. If there exists another set \\(T\\) such that the number got from multiplying all its elements is \\(988\\), \\(\\vert T \\vert\\) must also be \\(i\\). Since we can’t break down a prime any further, \\(\\vert T \\vert\\) can not change, if it changes, we are effectively introducing another prime, and we&rsquo;re no longer talking about \\(988\\) anymore.
Now assume there is a set \\(K\\) that similarly represents the number \\(988\\) in its ordered factors form, but \\(K \\ne S\\).
\\(K \\ne S\\) indicates there exists at least one element at \\(i\\) such that \\(k_i \\ne s_i\\) for \\(k_i \\in K\\) and \\(s_i \\in S\\).
$$ \\begin{align} \\exists k_i \\in K \\land \\exists s_i \\in S \\vert k_i \\ne s_i \\end{align} $$
Now let&rsquo;s assume further, and reduce the cases to just one. In other words instead of saying &ldquo;there exists at least one&rdquo;, thus saying &ldquo;there could be 5 or 10 or 100&rdquo;, we simply say &ldquo;there is one such an element&rdquo;. And the index of that element is \\(c\\).
Therefore \\(k_c \\ne s_c\\) for \\(k_c \\in K \\land s_c \\in S\\).
From our initial assumption of \\(S\\) and \\(K\\) representing the same number, if we take our a number from both of these ordered sets, from the same index, the resulting sets should also represent a same number (not \\(988\\) but another number, both of which are the same).
So, effectively we would be saying
$$ \\begin{align} \\frac{988}k_c &amp; = \\frac{988}s_c \\\\ \\frac{1}k_c &amp; = \\frac{1}s_c \\\\ k_c &amp; = s_c \\end{align} $$
This contradicts our initial assesment of \\(S \\ne K\\) and establishes that \\(S = K\\). Thus proving the prime factorization of a number is indeed unique.
If you are thinking about what if more than one elements were inequal? The answer is it wouldn&rsquo;t matter. The sets are ordered, two numbers at different indexes can not complement one another, unless they are the same, in which case they are the same as one number differring.
Again, this can be proved in our head through intuition. But a partially formal proof sometimes puts our mind at ease.
This theory has a lot of applications. Which I won’t be getting into today. Goal was to prove it “partially formally” - a mix of formal notations and logic, with a hint and approach of informality.
`,url:"https://debdut.blog/2024/03/fundamental-theory-of-arithmetic/"},"https://debdut.blog/tags/mathematics/":{title:"Mathematics",tags:[],content:"",url:"https://debdut.blog/tags/mathematics/"},"https://debdut.blog/tags/number-theory/":{title:"Number-Theory",tags:[],content:"",url:"https://debdut.blog/tags/number-theory/"},"https://debdut.blog/post/":{title:"Posts",tags:[],content:"",url:"https://debdut.blog/post/"},"https://debdut.blog/tags/":{title:"Tags",tags:[],content:"",url:"https://debdut.blog/tags/"},"https://debdut.blog/categories/":{title:"Categories",tags:[],content:"",url:"https://debdut.blog/categories/"},"https://debdut.blog/tags/deployment/":{title:"Deployment",tags:[],content:"",url:"https://debdut.blog/tags/deployment/"},"https://debdut.blog/categories/devops/":{title:"Devops",tags:[],content:"",url:"https://debdut.blog/categories/devops/"},"https://debdut.blog/tags/docker/":{title:"Docker",tags:[],content:"",url:"https://debdut.blog/tags/docker/"},"https://debdut.blog/2022/06/perpetual-rocket.chat-develop-deployment/":{title:"Perpetual Rocket.Chat Develop Deployment",tags:["docker","rocket.chat","deployment"],content:`Since joining Rocket.Chat last year I&rsquo;ve been having to deploy it uncountable times, multiple times in a single day even. One of the most critical things, is needing to check community issues on latest develop branch (to make sure it&rsquo;s not already fixed) everytime before funneling to product. So it was a lot of re-deploying every few days.
We do have a develop tagged docker image, but to actually be on the latest develop I&rsquo;d need to re-pull it every once in a while, and that doesn&rsquo;t really help much.
I wanted an instance, that is always on the latest develop branch.
A solution you might think of is a simple shell script with a systemd service. True. But, luckily, I came across Watchtower , and that seemed pretty neat.
So now, I&rsquo;ll be documenting how to keep a perpetual develop running instance of Rocket.Chat ;)
It&rsquo;s not just Rocket.Chat, you can use Watchtower with any OCI image, just make sure the tag you&rsquo;re targeting is not specific to patch (like target :4.2 instead of :4.2.3 to actually see a difference).
Install Docker &amp; Docker Compose curl -L https://get.docker.com | sh Deploy Rocket.Chat Head over to this pull request to grab the compose file (only support compose v2 FYI).
Before deploying, add a label to the rocketchat service;
com.centurylinklabs.watchtower.enable: &#34;true&#34; This will tell Watchtower to keep track of this service.
Deploy Watchtower Copy the following compose file to a diff location (or save with a diff name?).
version: &#39;3.0&#39; services: watchtower: image: containrrr/watchtower:1.3.0 volumes: [/run/docker.sock:/var/run/docker.sock:ro] command: --label-enable --cleanup It&rsquo;s a pretty simple template. You can change the tag if you wish. Do not forget the --cleanup arg, or else you&rsquo;ll run out of storage pretty soon :p.
Now just run compose [-f &lt;filename?&gt;] up -d for each template.
Your instance will now be always on latest develop.
For more information, read Watchtower&rsquo;s official documentation :)
`,url:"https://debdut.blog/2022/06/perpetual-rocket.chat-develop-deployment/"},"https://debdut.blog/tags/rocket.chat/":{title:"Rocket.chat",tags:[],content:"",url:"https://debdut.blog/tags/rocket.chat/"},"https://debdut.blog/tags/bash/":{title:"Bash",tags:[],content:"",url:"https://debdut.blog/tags/bash/"},"https://debdut.blog/tags/c/":{title:"C",tags:[],content:"",url:"https://debdut.blog/tags/c/"},"https://debdut.blog/2022/06/creating-shell-builtins/":{title:"Creating Shell Builtins",tags:["c","bash","shell","programming"],content:` What are my goals for this article? Before writing this, I was thinking about it from the reader&rsquo;s point of view, and it came to my attention that the goal of this article might get misinterpreted. So this section is to make sure that doesn&rsquo;t happen. My goal for this article, is very simple and straight forward. Following this, you&rsquo;ll have a much better understanding of what shell builtins are, and why you should use them instead of general commands, whenever you can. There is a section that shortly goes through the process of even creating one ourselves. But that should not be considered to be a tutorial. This article won&rsquo;t teach you how to create a built-ins yourself.
Word of caution Before moving forward, if you are an experienced Linux user or should I say a more technically advanced user, you might see some sections and think to yourself &ldquo;Well that ain&rsquo;t totally correct&rdquo;, and you will be correct to assume that. I&rsquo;ll not be going at depths for everything. My goal is to make sure the readers understand the topic in question. That includes new users. That&rsquo;s why I&rsquo;ll be hiding smaller details whenever necessary.
What are built-ins? Before we get into this exact question, I should explain first how exactly a command flow works. Say you&rsquo;ve opened a terminal, and enter a command like the following
grep &#39;something important&#39; a-file | wc -l What is happening behind the scenes? To understand builtins and why you should prefer them, this section is absolutely necessary. But to get to that, first, you&rsquo;ll be needing to understand a couple more things. I know this is getting deep already right? Bear with me. The following section takes care of the prerequisites.
Prerequisites What are processes?
Processes are basically running programs. When you start, say a file manager, you spawn a process, named that file manager. Your whole operating system runs consisting of many processes. Processes run alternatively. You might think &ldquo;Alternatively? What do you mean?&rdquo;. Well see the processor can&rsquo;t exactly run one single program to completion, can they? If that were to be true, then you couldn&rsquo;t even start an operating system, because there are some programs that are always running. We need them to stay that way. And if some process is already running, how can some other program run? Luckily that&rsquo;s not how they work. The CPU is the master here. CPU determines when and how long one process will be running. And it rotates this, quite fast, which is why we don&rsquo;t exactly notice anything, we think everything is running at once or simultaneously.
Technically yes, a lot of the processes do run simultaneously of different threads. But that&rsquo;s not our topic today.
Basically a process is a program, that&rsquo;s doing something. A program can spawn multiple processes to make its job completion faster. Here&rsquo;s a fun part to keep in mind, these individual processes have their own memory space. You can understand this analogy by thinking of an unmarried couple. The relationship is a program, each individual is a process. They both have their own house, job, car, etc. Processes of the same program are just like that.
What is exec?
Exec is a system call. Exec takes one argument and simply gives all the resources to that new process. It replaces the current process with the one you passed it.
A system call is basically a keyword that lets us use some of the kernel&rsquo;s features directly without any abstractions if permissible. You can also think of system calls being features that the kernel lets higher level programs (Like a file manager or text editor) use for a successful operation.
You can test exec with a shell command named (No surprises) exec. Try running exec &lt;your-file-manager&gt; in a terminal. You&rsquo;ll see the terminal closed, and the file manager opened. This is because exec replaced the current process, the terminal/shell prompt with a new one, the file manager.
What happens when you execute a command? Now that you have the understanding of what processes are and what exec is, the next question is, what happens when we write say cat filename? When you start a terminal, you have a total of two processes. One for the application itself, another for the shell, which in my case is bash. You can check that via a system monitor like the mate-system-monitor. Take a look at the picture below
Now when you execute a command, your shell spawns a new process, then replaces that process with the program you wanted to execute with exec. See the following diagram
missing sorry :p
Test this with sleep. Open a terminal, and run sleep 1d. Then open the system monitor, and navigate to the terminal. You&rsquo;ll see something like the following
So what is a builtin exactly? For starters, a builtin is not a binary file. You won&rsquo;t find it in your filesystem. Builtins are the shell&rsquo;s internal functions. If being specific, a builtin is a 48-byte data structure (Differs between hardware). When you use a builtin, a separate process is not spawned. A builtin to bash is the same as renaming a file is in a file manager. It&rsquo;s its own feature, it doesn&rsquo;t have to rely on any other program. This is important because a builtin essentially eliminates the initial system calls that bash had to use if it were an actual binary program. In other words, using builtins results in less overhead, and it&rsquo;s effectively much faster. Now should we test this? Absolutely!
One fine command that we can use, is echo. There was a time when experienced people in public forums or at other places used to say &ldquo;Don&rsquo;t use echo, use printf instead&rdquo;. This is because printf is a bash builtin whereas echo is an external command. That is not the case anymore. Try running type echo. You&rsquo;ll see something like the following.
debdut@mate-ubuntu:~/bash-5.0$ type echo echo is a shell builtin While it is a shell builtin, we also have our old binary file as well. It&rsquo;s located at /usr/bin/echo. Use the which command to find it. Now, run the following script
echo=/usr/bin/echo time { for i in {0..1000}; do $echo $i done } This script basically sets the variable echo to the binary echo, then prints the first 1000 numbers. It also keeps a record of how much time the whole process will take. On my computer, here&rsquo;s my result.
real	0m2.666s user	0m1.073s sys	0m1.662s Now change the variable&rsquo;s value from /usr/bin/echo to just echo. Rerun the script. I believe you don&rsquo;t even need to see the results. But still, just for the record,
real	0m0.009s user	0m0.004s sys	0m0.005s It&rsquo;s much much faster. I do hope now you&rsquo;re clear on what shell builtins are and why you should prefer them over other binary commands.
Test run, writing my own builtin The following section is not for everyone. Most are going to be fine with the information provided above. You&rsquo;ll need to know C if you want to understand any of the source code. You can just copy and paste everything to see the end result as well. Do note that I won&rsquo;t be explaining the source code much if any at all. So this isn&rsquo;t a tutorial of any kind.
Install bash-builtins
First, we&rsquo;ll need a package named bash-builtins. I&rsquo;m on Ubuntu 20.04. The package name may vary depending on your distribution. Consult your distribution&rsquo;s documentation/wiki.
sudo apt install bash-builtins -y Fix some paths
Next, we&rsquo;ll need to copy some files over. Execute the following command
sudo cp /usr/include/bash/include/* /usr/include/bash/ If you want to remove this package later, you&rsquo;ll have to manually remove the /usr/include/bash directory. Although it&rsquo;s around 500K in size. There&rsquo;s no reason to remove it, is there?
Copy and paste the source code
#include &lt;bash/config.h&gt; #include &lt;unistd.h&gt; #include &lt;bash/posixjmp.h&gt; #include &lt;bash/shell.h&gt; #include &lt;bash/builtins.h&gt; #include &lt;stdio.h&gt; int sleep_(){ sleep(5); return EXECUTION_SUCCESS; } char *doc[]={ &#34;Sleep for 5 minutes&#34;, 0 }; struct builtin sleep_struct={ &#34;sleep&#34;, sleep_, BUILTIN_ENABLED, doc, &#34;Usage: sleep&#34;, NULL }; Copy the code above, and save it in a file named sleep.c. This is basically a builtin command, identical to sleep, much simpler though. It does nothing but waits for 5 seconds.
Compile the program
Because we aren&rsquo;t going to rebuild bash, we&rsquo;re gonna build a shared library that bash will load to memory when needed. Run the following command
gcc -shared -fpic -o sleep.so sleep.c Enable the builtin
Now you can enable the builtin using the enable builtin. This command manages the builtins. Use the following command
enable -f \`pwd\`/sleep.so sleep Now you can test the builtin in two ways,
Using the type command Simply run type sleep. You should see something like this
debdut@mate-ubuntu:~/builtins$ type sleep sleep is a shell builtin The older sleep can be found at /usr/bin/sleep (Use which).
Compare the process count
Remember previously we used the sleep command to see how there&rsquo;s a separate process getting generated? Let&rsquo;s try that out now. Our builtin basically sleeps for 5 seconds. Open the system monitor and the terminal side by side. Then simply run sleep. Now notice the system monitor, there&rsquo;s no process generated. It was run internally.
`,url:"https://debdut.blog/2022/06/creating-shell-builtins/"},"https://debdut.blog/tags/programming/":{title:"Programming",tags:[],content:"",url:"https://debdut.blog/tags/programming/"},"https://debdut.blog/categories/shell/":{title:"Shell",tags:[],content:"",url:"https://debdut.blog/categories/shell/"},"https://debdut.blog/tags/shell/":{title:"Shell",tags:[],content:"",url:"https://debdut.blog/tags/shell/"},"https://debdut.blog/categories/system-programming/":{title:"System-Programming",tags:[],content:"",url:"https://debdut.blog/categories/system-programming/"},"https://debdut.blog/search/":{title:"Search",tags:[],content:"",url:"https://debdut.blog/search/"}}</script><script defer src=/js/lunr.js></script><script defer src=/js/search.js></script></footer></body></html>